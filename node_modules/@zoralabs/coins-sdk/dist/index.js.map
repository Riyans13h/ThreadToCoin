{"version":3,"sources":["../src/actions/createCoin.ts","../src/constants.ts","../src/utils/validateClientNetwork.ts","../src/metadata/cleanAndValidateMetadataURI.ts","../src/metadata/validateMetadataJSON.ts","../src/metadata/validateMetadataURIContent.ts","../src/utils/attribution.ts","../src/utils/poolConfigUtils.ts","../src/actions/tradeCoin.ts","../src/actions/getOnchainCoinDetails.ts","../src/actions/updateCoinURI.ts","../src/actions/updatePayoutRecipient.ts","../src/client/client.gen.ts","../src/client/sdk.gen.ts","../src/api/api-key.ts","../src/api/queries.ts","../src/api/explore.ts"],"sourcesContent":["import { coinFactoryABI as zoraFactoryImplABI } from \"@zoralabs/protocol-deployments\";\nimport {\n  Address,\n  TransactionReceipt,\n  WalletClient,\n  SimulateContractParameters,\n  ContractEventArgsFromTopics,\n  parseEventLogs,\n  zeroAddress,\n  keccak256,\n  toBytes,\n  Hex,\n  Account,\n} from \"viem\";\nimport { COIN_FACTORY_ADDRESS } from \"../constants\";\nimport { validateClientNetwork } from \"../utils/validateClientNetwork\";\nimport { GenericPublicClient } from \"src/utils/genericPublicClient\";\nimport { validateMetadataURIContent, ValidMetadataURI } from \"src/metadata\";\nimport { getAttribution } from \"../utils/attribution\";\nimport { base, baseSepolia } from \"viem/chains\";\nimport {\n  COIN_ETH_PAIR_POOL_CONFIG,\n  COIN_ZORA_PAIR_POOL_CONFIG,\n} from \"src/utils/poolConfigUtils\";\n\nexport type CoinDeploymentLogArgs = ContractEventArgsFromTopics<\n  typeof zoraFactoryImplABI,\n  \"CoinCreatedV4\"\n>;\n\nexport enum DeployCurrency {\n  ZORA = 1,\n  ETH = 2,\n}\n\nexport type CreateCoinArgs = {\n  name: string;\n  symbol: string;\n  uri: ValidMetadataURI;\n  chainId: number;\n  owners?: Address[];\n  payoutRecipient: Address;\n  platformReferrer?: Address;\n  currency?: DeployCurrency;\n};\n\nfunction getPoolConfig(currency: DeployCurrency, chainId: number) {\n  if (currency === DeployCurrency.ZORA && chainId == baseSepolia.id) {\n    throw new Error(\"ZORA is not supported on Base Sepolia\");\n  }\n\n  switch (currency) {\n    case DeployCurrency.ZORA:\n      return COIN_ZORA_PAIR_POOL_CONFIG[\n        chainId as keyof typeof COIN_ZORA_PAIR_POOL_CONFIG\n      ];\n    case DeployCurrency.ETH:\n      return COIN_ETH_PAIR_POOL_CONFIG[\n        chainId as keyof typeof COIN_ETH_PAIR_POOL_CONFIG\n      ];\n    default:\n      throw new Error(\"Invalid currency\");\n  }\n}\n\nexport async function createCoinCall({\n  name,\n  symbol,\n  uri,\n  owners,\n  payoutRecipient,\n  currency,\n  chainId = base.id,\n  platformReferrer = \"0x0000000000000000000000000000000000000000\",\n}: CreateCoinArgs): Promise<\n  SimulateContractParameters<typeof zoraFactoryImplABI, \"deploy\">\n> {\n  if (!owners) {\n    owners = [payoutRecipient];\n  }\n\n  if (!currency) {\n    currency = chainId !== base.id ? DeployCurrency.ETH : DeployCurrency.ZORA;\n  }\n\n  const poolConfig = getPoolConfig(currency, chainId);\n\n  // This will throw an error if the metadata is not valid\n  await validateMetadataURIContent(uri);\n\n  return {\n    abi: zoraFactoryImplABI,\n    functionName: \"deploy\",\n    address: COIN_FACTORY_ADDRESS,\n    args: [\n      payoutRecipient,\n      owners,\n      uri,\n      name,\n      symbol,\n      poolConfig,\n      platformReferrer,\n      zeroAddress, // hookAddress\n      \"0x\" as Hex, // hookData\n      keccak256(toBytes(Math.random().toString())), // coinSalt\n    ],\n    dataSuffix: getAttribution(),\n  } as const;\n}\n\n/**\n * Gets the deployed coin address from transaction receipt logs\n * @param receipt Transaction receipt containing the CoinCreated event\n * @returns The deployment information if found\n */\nexport function getCoinCreateFromLogs(\n  receipt: TransactionReceipt,\n): CoinDeploymentLogArgs | undefined {\n  const eventLogs = parseEventLogs({\n    abi: zoraFactoryImplABI,\n    logs: receipt.logs,\n  });\n\n  return eventLogs.find((log) => log.eventName === \"CoinCreatedV4\")?.args;\n}\n\n// Update createCoin to return both receipt and coin address\nexport async function createCoin(\n  call: CreateCoinArgs,\n  walletClient: WalletClient,\n  publicClient: GenericPublicClient,\n  options?: {\n    gasMultiplier?: number;\n    account?: Account | Address;\n  },\n) {\n  validateClientNetwork(publicClient);\n\n  const createCoinRequest = await createCoinCall(call);\n  const { request } = await publicClient.simulateContract({\n    ...createCoinRequest,\n    account: options?.account ?? walletClient.account,\n  });\n\n  // Add a 2/5th buffer on gas.\n  if (request.gas) {\n    // Gas limit multiplier is a percentage argument.\n    request.gas = (request.gas * BigInt(options?.gasMultiplier ?? 100)) / 100n;\n  }\n  const hash = await walletClient.writeContract(request);\n  const receipt = await publicClient.waitForTransactionReceipt({ hash });\n  const deployment = getCoinCreateFromLogs(receipt);\n\n  return {\n    hash,\n    receipt,\n    address: deployment?.coin,\n    deployment,\n  };\n}\n","import { coinFactoryAddress as zoraFactoryImplAddress } from \"@zoralabs/protocol-deployments\";\nimport { Address } from \"viem\";\nimport { base } from \"viem/chains\";\n\n// this is the same across all chains due to deterministic deploys.\nexport const COIN_FACTORY_ADDRESS = zoraFactoryImplAddress[\"8453\"] as Address;\n\nexport const SUPERCHAIN_WETH_ADDRESS =\n  \"0x4200000000000000000000000000000000000006\";\n\nexport const USDC_WETH_POOLS_BY_CHAIN: Record<number, Address> = {\n  [base.id]: \"0xd0b53D9277642d899DF5C87A3966A349A798F224\",\n};\n","import { PublicClient } from \"viem\";\nimport { base, baseSepolia } from \"viem/chains\";\n\nexport const validateClientNetwork = (\n  publicClient: PublicClient<any, any, any, any>,\n) => {\n  const clientChainId = publicClient?.chain?.id;\n  if (clientChainId === base.id) {\n    return;\n  }\n  if (clientChainId === baseSepolia.id) {\n    return;\n  }\n\n  throw new Error(\n    \"Client network needs to be base or baseSepolia for current coin deployments.\",\n  );\n};\n","export type ValidMetadataURI =\n  | `ipfs://${string}`\n  | `ar://${string}`\n  | `data:${string}`\n  | `https://${string}`;\n\n/**\n * Clean the metadata URI to HTTPS format\n * @param metadataURI - The metadata URI to clean from IPFS or Arweave\n * @returns The cleaned metadata URI\n * @throws If the metadata URI is a data URI\n */\nexport function cleanAndValidateMetadataURI(uri: ValidMetadataURI) {\n  if (uri.startsWith(\"ipfs://\")) {\n    return uri.replace(\n      \"ipfs://\",\n      \"https://magic.decentralized-content.com/ipfs/\",\n    );\n  }\n  if (uri.startsWith(\"ar://\")) {\n    return uri.replace(\"ar://\", \"http://arweave.net/\");\n  }\n  if (uri.startsWith(\"data:\")) {\n    return uri;\n    // throw new Error(\"Data URIs are not supported\");\n  }\n  if (uri.startsWith(\"http://\") || uri.startsWith(\"https://\")) {\n    return uri;\n  }\n\n  throw new Error(\"Invalid metadata URI\");\n}\n","export type ValidMetadataJSON = {\n  name: string;\n  description: string;\n  image: string;\n  animation_url?: string;\n  content?: { uri: string; mime?: string };\n};\n\nfunction validateURIString(uri: unknown) {\n  if (typeof uri !== \"string\") {\n    throw new Error(\"URI must be a string\");\n  }\n  if (uri.startsWith(\"ipfs://\")) {\n    return true;\n  }\n  if (uri.startsWith(\"ar://\")) {\n    return true;\n  }\n  if (uri.startsWith(\"https://\")) {\n    return true;\n  }\n  if (uri.startsWith(\"data:\")) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Validate the metadata JSON object\n * @param metadata - The metadata object to validate\n */\nexport function validateMetadataJSON(metadata: ValidMetadataJSON | unknown) {\n  if (typeof metadata !== \"object\" || !metadata) {\n    throw new Error(\"Metadata must be an object and exist\");\n  }\n  if (typeof (metadata as { name: unknown }).name !== \"string\") {\n    throw new Error(\"Metadata name is required and must be a string\");\n  }\n  if (typeof (metadata as { description: unknown }).description !== \"string\") {\n    throw new Error(\"Metadata description is required and must be a string\");\n  }\n  if (typeof (metadata as { image: unknown }).image === \"string\") {\n    if (!validateURIString((metadata as { image: string }).image)) {\n      throw new Error(\"Metadata image is not a valid URI\");\n    }\n  } else {\n    throw new Error(\"Metadata image is required and must be a string\");\n  }\n  if (\"animation_url\" in metadata) {\n    if (\n      typeof (metadata as { animation_url?: unknown }).animation_url !==\n      \"string\"\n    ) {\n      throw new Error(\"Metadata animation_url, if provided, must be a string\");\n    }\n    if (!validateURIString(metadata.animation_url)) {\n      throw new Error(\"Metadata animation_url is not a valid URI\");\n    }\n  }\n  const content =\n    \"content\" in metadata && (metadata as { content?: unknown }).content;\n  if (content) {\n    if (typeof (content as { uri?: unknown }).uri !== \"string\") {\n      throw new Error(\"If provided, content.uri must be a string\");\n    }\n    if (!validateURIString((content as { uri: string }).uri)) {\n      throw new Error(\"If provided, content.uri must be a valid URI string\");\n    }\n    if (typeof (content as { mime?: unknown }).mime !== \"string\") {\n      throw new Error(\"If provided, content.mime must be a string\");\n    }\n  }\n\n  return true;\n}\n","import {\n  cleanAndValidateMetadataURI,\n  ValidMetadataURI,\n} from \"./cleanAndValidateMetadataURI\";\nimport { validateMetadataJSON } from \"./validateMetadataJSON\";\n\n/**\n * Validate the metadata URI Content\n * @param metadataURI - The metadata URI to validate\n * @returns true if the metadata is valid, throws an error otherwise\n */\nexport async function validateMetadataURIContent(\n  metadataURI: ValidMetadataURI,\n) {\n  const cleanedURI = cleanAndValidateMetadataURI(metadataURI);\n  const response = await fetch(cleanedURI);\n  if (!response.ok) {\n    throw new Error(\"Metadata fetch failed\");\n  }\n  if (\n    ![\"application/json\", \"text/plain\"].includes(\n      response.headers.get(\"content-type\") ?? \"\",\n    )\n  ) {\n    throw new Error(\"Metadata is not a valid JSON or plain text response type\");\n  }\n  const metadataJson = await response.json();\n  return validateMetadataJSON(metadataJson);\n}\n","import { Hex, keccak256, slice, toHex } from \"viem\";\n\nexport function getAttribution(): Hex {\n  const hash = keccak256(toHex(\"api-sdk.zora.engineering\"));\n  return slice(hash, 0, 4) as Hex;\n}\n","import { encodeMultiCurvePoolConfig } from \"@zoralabs/protocol-deployments\";\nimport { parseUnits, zeroAddress } from \"viem\";\nimport { base, baseSepolia } from \"viem/chains\";\n\nconst ZORA_DECIMALS = 18;\n\n/**\n * =========================\n * COIN_ETH_PAIR_POOL_CONFIG\n * =========================\n */\n\nexport const ZORA_ADDRESS = \"0x1111111111166b7fe7bd91427724b487980afc69\";\n\nconst COIN_ETH_PAIR_LOWER_TICK = -250000;\nconst COIN_ETH_PAIR_UPPER_TICK = -195_000;\nconst COIN_ETH_PAIR_NUM_DISCOVERY_POSITIONS = 11;\nconst COIN_ETH_PAIR_MAX_DISCOVERY_SUPPLY_SHARE = parseUnits(\"0.05\", 18);\n\nexport const COIN_ETH_PAIR_POOL_CONFIG = {\n  [base.id]: encodeMultiCurvePoolConfig({\n    currency: zeroAddress,\n    tickLower: [COIN_ETH_PAIR_LOWER_TICK],\n    tickUpper: [COIN_ETH_PAIR_UPPER_TICK],\n    numDiscoveryPositions: [COIN_ETH_PAIR_NUM_DISCOVERY_POSITIONS],\n    maxDiscoverySupplyShare: [COIN_ETH_PAIR_MAX_DISCOVERY_SUPPLY_SHARE],\n  }),\n  [baseSepolia.id]: encodeMultiCurvePoolConfig({\n    currency: zeroAddress,\n    tickLower: [COIN_ETH_PAIR_LOWER_TICK],\n    tickUpper: [COIN_ETH_PAIR_UPPER_TICK],\n    numDiscoveryPositions: [COIN_ETH_PAIR_NUM_DISCOVERY_POSITIONS],\n    maxDiscoverySupplyShare: [COIN_ETH_PAIR_MAX_DISCOVERY_SUPPLY_SHARE],\n  }),\n};\n\nconst COIN_ZORA_PAIR_LOWER_TICK = -138_000; // ( -250000 in ETH land ~= $23 = -138_000 in Zora token land at .022)\nconst COIN_ZORA_PAIR_UPPER_TICK = -81_000; // (-195_000 ~= 5782 =  -81_000 in Zora token land at .022)\nconst COIN_ZORA_PAIR_NUM_DISCOVERY_POSITIONS = 11;\nconst COIN_ZORA_PAIR_MAX_DISCOVERY_SUPPLY_SHARE = parseUnits(\n  \"0.05\",\n  ZORA_DECIMALS,\n);\n\nexport const COIN_ZORA_PAIR_POOL_CONFIG = {\n  [base.id]: encodeMultiCurvePoolConfig({\n    currency: ZORA_ADDRESS,\n    tickLower: [COIN_ZORA_PAIR_LOWER_TICK],\n    tickUpper: [COIN_ZORA_PAIR_UPPER_TICK],\n    numDiscoveryPositions: [COIN_ZORA_PAIR_NUM_DISCOVERY_POSITIONS],\n    maxDiscoverySupplyShare: [COIN_ZORA_PAIR_MAX_DISCOVERY_SUPPLY_SHARE],\n  }),\n};\n","import { coinABI } from \"@zoralabs/protocol-deployments\";\nimport { validateClientNetwork } from \"../utils/validateClientNetwork\";\nimport {\n  Address,\n  TransactionReceipt,\n  WalletClient,\n  SimulateContractParameters,\n  parseEther,\n  zeroAddress,\n  ContractEventArgsFromTopics,\n  parseEventLogs,\n} from \"viem\";\nimport { baseSepolia } from \"viem/chains\";\nimport { GenericPublicClient } from \"src/utils/genericPublicClient\";\nimport { getAttribution } from \"../utils/attribution\";\n// Define trade event args type\n\nexport type SellEventArgs = ContractEventArgsFromTopics<\n  typeof coinABI,\n  \"CoinSell\"\n>;\nexport type BuyEventArgs = ContractEventArgsFromTopics<\n  typeof coinABI,\n  \"CoinBuy\"\n>;\n\nexport type TradeEventArgs = SellEventArgs | BuyEventArgs;\n\n// We'll use this address to ensure it will have funds to simulate an eth trade.\n// @dev: This only works on OP chains and is a fix for a bug. Another approach should be taken long term.\nconst OP_BRIDGE_ADDRESS =\n  \"0x4200000000000000000000000000000000000016\" as Address;\n\n/**\n * Simulates a buy order to get the expected output amount\n * @param {Object} params - The simulation parameters\n * @param {Address} params.target - The target coin contract address\n * @param {bigint} params.requestedOrderSize - The desired input amount for the buy\n * @param {PublicClient} params.publicClient - The viem public client instance\n * @returns {Promise<{orderSize: bigint, amountOut: bigint}>} The simulated order size and output amount\n */\nexport async function simulateBuy({\n  target,\n  requestedOrderSize,\n  publicClient,\n}: {\n  target: Address;\n  requestedOrderSize: bigint;\n  publicClient: GenericPublicClient;\n}): Promise<{ orderSize: bigint; amountOut: bigint }> {\n  const numberResult = await publicClient.simulateContract({\n    address: target,\n    abi: coinABI,\n    functionName: \"buy\",\n    dataSuffix: getAttribution(),\n    args: [\n      OP_BRIDGE_ADDRESS,\n      requestedOrderSize,\n      0n, // minAmountOut\n      0n, // sqrtPriceLimitX96\n      zeroAddress, // tradeReferrer\n    ],\n    // We want to ensure that the multicall3 contract has enough ETH to buy in the simulation\n    stateOverride: [\n      {\n        address: baseSepolia.contracts.multicall3.address,\n        balance: parseEther(\"10000000\"),\n      },\n    ],\n  });\n  const orderSize = numberResult.result[0];\n  const amountOut = numberResult.result[1];\n  return { orderSize, amountOut };\n}\n\n/**\n * Parameters for creating a trade call\n * @typedef {Object} TradeParams\n * @property {'sell' | 'buy'} direction - The trade direction\n * @property {Address} target - The target coin contract address\n * @property {Object} args - The trade arguments\n * @property {Address} args.recipient - The recipient of the trade output\n * @property {bigint} args.orderSize - The size of the order\n * @property {bigint} [args.minAmountOut] - The minimum amount to receive\n * @property {bigint} [args.sqrtPriceLimitX96] - The price limit for the trade\n * @property {Address} [args.tradeReferrer] - The referrer address for the trade\n */\nexport type TradeParams = {\n  direction: \"sell\" | \"buy\";\n  target: Address;\n  args: {\n    recipient: Address;\n    orderSize: bigint;\n    minAmountOut?: bigint;\n    sqrtPriceLimitX96?: bigint;\n    tradeReferrer?: Address;\n  };\n};\n\n/**\n * Creates a trade call parameters object for buy or sell\n * @param {TradeParams} params - The trade parameters\n * @returns {SimulateContractParameters} The contract call parameters\n */\nexport function tradeCoinCall({\n  target,\n  direction,\n  args: {\n    recipient,\n    orderSize,\n    minAmountOut = 0n,\n    sqrtPriceLimitX96 = 0n,\n    tradeReferrer = zeroAddress,\n  },\n}: TradeParams): SimulateContractParameters {\n  return {\n    abi: coinABI,\n    functionName: direction,\n    address: target,\n    args: [\n      recipient,\n      orderSize,\n      minAmountOut,\n      sqrtPriceLimitX96,\n      tradeReferrer,\n    ],\n    value: direction === \"buy\" ? orderSize : 0n,\n  } as const;\n}\n\n/**\n * Gets the trade event from transaction receipt logs\n * @param {TransactionReceipt} receipt - The transaction receipt containing the logs\n * @param {'buy' | 'sell'} direction - The direction of the trade\n * @returns {TradeEventArgs | undefined} The decoded trade event args if found\n */\nexport function getTradeFromLogs(\n  receipt: TransactionReceipt,\n  direction: \"buy\" | \"sell\",\n): TradeEventArgs | undefined {\n  const eventLogs = parseEventLogs({\n    abi: coinABI,\n    logs: receipt.logs,\n  });\n\n  if (direction === \"buy\") {\n    return eventLogs.find((log) => log.eventName === \"CoinBuy\")?.args;\n  }\n  return eventLogs.find((log) => log.eventName === \"CoinSell\")?.args;\n}\n\n/**\n * Executes a trade transaction\n * @param {TradeParams} params - The trade parameters\n * @param {PublicClient} publicClient - The viem public client instance\n * @param {WalletClient} walletClient - The viem wallet client instance\n * @returns {Promise<{\n *   hash: `0x${string}`,\n *   receipt: TransactionReceipt,\n *   trade: TradeEventArgs | undefined\n * }>} The transaction result with trade details\n */\nexport async function tradeCoin(\n  params: TradeParams,\n  walletClient: WalletClient,\n  publicClient: GenericPublicClient,\n) {\n  validateClientNetwork(publicClient);\n  const { request } = await publicClient.simulateContract({\n    ...tradeCoinCall(params),\n    account: walletClient.account,\n  });\n  const hash = await walletClient.writeContract(request);\n  const receipt = await publicClient.waitForTransactionReceipt({ hash });\n  const trade = getTradeFromLogs(receipt, params.direction);\n\n  return {\n    hash,\n    receipt,\n    trade,\n  };\n}\n","import { coinABI, iUniswapV3PoolABI } from \"@zoralabs/protocol-deployments\";\nimport {\n  SUPERCHAIN_WETH_ADDRESS,\n  USDC_WETH_POOLS_BY_CHAIN,\n} from \"../constants\";\nimport { GenericPublicClient } from \"../utils/genericPublicClient\";\nimport { validateClientNetwork } from \"../utils/validateClientNetwork\";\nimport {\n  Address,\n  erc20Abi,\n  formatEther,\n  isAddressEqual,\n  zeroAddress,\n} from \"viem\";\n\ntype Slot0Result = {\n  sqrtPriceX96: bigint;\n  tick: number;\n  observationIndex: number;\n  observationCardinality: number;\n  observationCardinalityNext: number;\n  feeProtocol: number;\n  unlocked: boolean;\n};\n\ntype PricingResult = {\n  eth: bigint;\n  usdc: bigint | null;\n  usdcDecimal: number | null;\n  ethDecimal: number;\n};\n\n/**\n * Represents the current state of a coin\n * @typedef {Object} OnchainCoinDetails\n * @property {bigint} balance - The user's balance of the coin\n * @property {PricingResult} marketCap - The market cap of the coin\n * @property {PricingResult} liquidity - The liquidity of the coin\n * @property {Address} pool - Pool address\n * @property {Slot0Result} poolState - Current state of the UniswapV3 pool\n * @property {Address[]} owners - List of owners for the coin\n * @property {Address} payoutRecipient - The payout recipient address\n */\nexport type OnchainCoinDetails = {\n  balance: bigint;\n  marketCap: PricingResult;\n  liquidity: PricingResult;\n  pool: Address;\n  poolState: Slot0Result;\n  owners: readonly Address[];\n  payoutRecipient: Address;\n};\n\n/**\n * Gets the current state of a coin for a user\n * @param {Object} params - The query parameters\n * @param {Address} params.coin - The coin contract address\n * @param {Address} params.user - The user address to check balance for\n * @param {PublicClient} params.publicClient - The viem public client instance\n * @returns {Promise<OnchainCoinDetails>} The coin's current state\n */\nexport async function getOnchainCoinDetails({\n  coin,\n  user = zeroAddress,\n  publicClient,\n}: {\n  coin: Address;\n  user?: Address;\n  publicClient: GenericPublicClient;\n}): Promise<OnchainCoinDetails> {\n  validateClientNetwork(publicClient);\n  const [balance, pool, owners, payoutRecipient] = await publicClient.multicall(\n    {\n      contracts: [\n        {\n          address: coin,\n          abi: coinABI,\n          functionName: \"balanceOf\",\n          args: [user],\n        },\n        {\n          address: coin,\n          abi: coinABI,\n          functionName: \"poolAddress\",\n        },\n        {\n          address: coin,\n          abi: coinABI,\n          functionName: \"owners\",\n        },\n        {\n          address: coin,\n          abi: coinABI,\n          functionName: \"payoutRecipient\",\n        },\n      ],\n      allowFailure: false,\n    },\n  );\n\n  const USDC_WETH_POOL = USDC_WETH_POOLS_BY_CHAIN[publicClient.chain?.id || 0];\n\n  const [\n    coinWethPoolSlot0,\n    coinWethPoolToken0,\n    coinReservesRaw,\n    coinTotalSupply,\n    wethReservesRaw,\n    usdcWethSlot0,\n  ] = await publicClient.multicall({\n    contracts: [\n      {\n        address: pool,\n        abi: iUniswapV3PoolABI,\n        functionName: \"slot0\",\n      },\n      {\n        address: pool,\n        abi: iUniswapV3PoolABI,\n        functionName: \"token0\",\n      },\n      {\n        address: coin,\n        abi: erc20Abi,\n        functionName: \"balanceOf\",\n        args: [pool],\n      },\n      {\n        address: coin,\n        abi: coinABI,\n        functionName: \"totalSupply\",\n      },\n      {\n        address: SUPERCHAIN_WETH_ADDRESS,\n        abi: erc20Abi,\n        functionName: \"balanceOf\",\n        args: [pool],\n      },\n      {\n        address: USDC_WETH_POOL ?? coin,\n        abi: iUniswapV3PoolABI,\n        functionName: \"slot0\",\n      },\n    ],\n    allowFailure: false,\n  });\n\n  const wethPriceInUsdc = USDC_WETH_POOL\n    ? uniswapV3SqrtPriceToBigIntScaled(\n        usdcWethSlot0.sqrtPriceX96,\n        18,\n        6,\n        true,\n        18,\n      )\n    : null;\n\n  const coinPriceInWeth = uniswapV3SqrtPriceToBigIntScaled(\n    coinWethPoolSlot0.sqrtPriceX96,\n    18,\n    18,\n    isAddressEqual(coinWethPoolToken0, coin),\n    18,\n  );\n\n  // Divide by 10^18 to remove percision from `coinPriceInWeth` after math since bigint is decimal.\n  const marketCap = (coinPriceInWeth * coinTotalSupply) / 10n ** 18n;\n\n  const wethLiquidity = wethReservesRaw;\n  // Divide by 10^18 to remove percision from `coinPriceInWeth` after math since bigint is decimal.\n  const tokenLiquidity = (coinReservesRaw * coinPriceInWeth) / 10n ** 18n;\n\n  return {\n    balance,\n    pool,\n    owners,\n    payoutRecipient,\n    marketCap: convertEthOutput(marketCap, wethPriceInUsdc),\n    liquidity: convertEthOutput(\n      wethLiquidity + tokenLiquidity,\n      wethPriceInUsdc,\n    ),\n    poolState: coinWethPoolSlot0,\n  };\n}\n\nfunction convertEthOutput(amountETH: bigint, wethToUsdc: bigint | null) {\n  return {\n    eth: amountETH,\n    ethDecimal: parseFloat(formatEther(amountETH)),\n    usdc: wethToUsdc ? amountETH * wethToUsdc : null,\n    usdcDecimal: wethToUsdc\n      ? parseFloat(formatEther((amountETH * wethToUsdc) / 10n ** 18n))\n      : null,\n  };\n}\n\nfunction uniswapV3SqrtPriceToBigIntScaled(\n  sqrtPriceX96: bigint,\n  token0Decimals: number,\n  token1Decimals: number,\n  isToken0Coin: boolean,\n  scaleDecimals: number = 18,\n): bigint {\n  // (sqrtPrice^2 / 2^192) => ratio\n  // We'll do: ratioScaled = (sqrtPrice^2 * 10^scaleDecimals) / 2^192\n  const numerator = sqrtPriceX96 * sqrtPriceX96;\n  const denominator = 2n ** 192n;\n  const scaleFactor = 10n ** BigInt(scaleDecimals);\n\n  // raw ratioScaled\n  let ratioScaled = (numerator * scaleFactor) / denominator; // BigInt\n\n  // Adjust for difference in decimals:\n  // ratioScaled *= 10^(dec0 - dec1)\n  const decimalsDiff = BigInt(token0Decimals - token1Decimals);\n  if (decimalsDiff > 0n) {\n    ratioScaled *= 10n ** decimalsDiff;\n  } else if (decimalsDiff < 0n) {\n    ratioScaled /= 10n ** -decimalsDiff;\n  }\n\n  if (!isToken0Coin) {\n    // We want the reciprocal: coin is token1 => coinPriceInToken0 = 1 / ratio\n    // But we also want it scaled by 10^scaleDecimals\n    // reciprocalScaled = (10^scaleDecimals * 10^(decimalsDiff)) / ratioScaled\n    // (assuming ratioScaled != 0)\n    if (ratioScaled === 0n) {\n      return 0n; // or some huge number representing infinity\n    }\n    ratioScaled = (scaleFactor * scaleFactor) / ratioScaled;\n    // or if we already included decimalsDiff above, handle carefully.\n  }\n\n  return ratioScaled;\n}\n","import { coinABI } from \"@zoralabs/protocol-deployments\";\nimport { validateClientNetwork } from \"../utils/validateClientNetwork\";\nimport {\n  Address,\n  parseEventLogs,\n  SimulateContractParameters,\n  WalletClient,\n} from \"viem\";\nimport { GenericPublicClient } from \"src/utils/genericPublicClient\";\nimport { getAttribution } from \"../utils/attribution\";\n\nexport type UpdateCoinURIArgs = {\n  coin: Address;\n  newURI: string;\n};\n\nexport function updateCoinURICall({\n  newURI,\n  coin,\n}: UpdateCoinURIArgs): SimulateContractParameters {\n  if (!newURI.startsWith(\"ipfs://\")) {\n    throw new Error(\"URI needs to be an ipfs:// prefix uri\");\n  }\n\n  return {\n    abi: coinABI,\n    address: coin,\n    functionName: \"setContractURI\",\n    args: [newURI],\n    dataSuffix: getAttribution(),\n  };\n}\n\nexport async function updateCoinURI(\n  args: UpdateCoinURIArgs,\n  walletClient: WalletClient,\n  publicClient: GenericPublicClient,\n) {\n  validateClientNetwork(publicClient);\n  const call = updateCoinURICall(args);\n  const { request } = await publicClient.simulateContract({\n    ...call,\n    account: walletClient.account!,\n  });\n  const hash = await walletClient.writeContract(request);\n  const receipt = await publicClient.waitForTransactionReceipt({ hash });\n  const eventLogs = parseEventLogs({ abi: coinABI, logs: receipt.logs });\n  const uriUpdated = eventLogs.find(\n    (log) => log.eventName === \"ContractURIUpdated\",\n  );\n\n  return { hash, receipt, uriUpdated };\n}\n","import { coinABI } from \"@zoralabs/protocol-deployments\";\nimport { validateClientNetwork } from \"../utils/validateClientNetwork\";\nimport {\n  Address,\n  parseEventLogs,\n  SimulateContractParameters,\n  WalletClient,\n} from \"viem\";\nimport { GenericPublicClient } from \"src/utils/genericPublicClient\";\nimport { getAttribution } from \"../utils/attribution\";\n\nexport type UpdatePayoutRecipientArgs = {\n  coin: Address;\n  newPayoutRecipient: string;\n};\n\nexport function updatePayoutRecipientCall({\n  newPayoutRecipient,\n  coin,\n}: UpdatePayoutRecipientArgs): SimulateContractParameters {\n  return {\n    abi: coinABI,\n    address: coin,\n    functionName: \"setPayoutRecipient\",\n    args: [newPayoutRecipient],\n    dataSuffix: getAttribution(),\n  };\n}\n\nexport async function updatePayoutRecipient(\n  args: UpdatePayoutRecipientArgs,\n  walletClient: WalletClient,\n  publicClient: GenericPublicClient,\n) {\n  validateClientNetwork(publicClient);\n  const call = updatePayoutRecipientCall(args);\n  const { request } = await publicClient.simulateContract({\n    ...call,\n    account: walletClient.account!,\n  });\n  const hash = await walletClient.writeContract(request);\n  const receipt = await publicClient.waitForTransactionReceipt({ hash });\n  const eventLogs = parseEventLogs({ abi: coinABI, logs: receipt.logs });\n  const payoutRecipientUpdated = eventLogs.find(\n    (log) => log.eventName === \"CoinPayoutRecipientUpdated\",\n  );\n\n  return { hash, receipt, payoutRecipientUpdated };\n}\n","// This file is auto-generated by @hey-api/openapi-ts\n\nimport type { ClientOptions } from \"./types.gen\";\nimport {\n  type Config,\n  type ClientOptions as DefaultClientOptions,\n  createClient,\n  createConfig,\n} from \"@hey-api/client-fetch\";\n\n/**\n * The `createClientConfig()` function will be called on client initialization\n * and the returned object will become the client's initial configuration.\n *\n * You may want to initialize your client this way instead of calling\n * `setConfig()`. This is useful for example if you're using Next.js\n * to ensure your client always has the correct values.\n */\nexport type CreateClientConfig<T extends DefaultClientOptions = ClientOptions> =\n  (\n    override?: Config<DefaultClientOptions & T>,\n  ) => Config<Required<DefaultClientOptions> & T>;\n\nexport const client = createClient(\n  createConfig<ClientOptions>({\n    baseUrl: \"https://api-sdk.zora.engineering/\",\n  }),\n);\n","// This file is auto-generated by @hey-api/openapi-ts\n\nimport type {\n  Options as ClientOptions,\n  TDataShape,\n  Client,\n} from \"@hey-api/client-fetch\";\nimport type {\n  GetApiKeyData,\n  GetApiKeyResponse,\n  GetCoinData,\n  GetCoinResponse,\n  GetCoinCommentsData,\n  GetCoinCommentsResponse,\n  GetCoinsData,\n  GetCoinsResponse,\n  SetCreateUploadJwtData,\n  SetCreateUploadJwtResponse,\n  GetExploreData,\n  GetExploreResponse,\n  GetProfileData,\n  GetProfileResponse,\n  GetProfileBalancesData,\n  GetProfileBalancesResponse,\n  GetProfileCoinsData,\n  GetProfileCoinsResponse,\n} from \"./types.gen\";\nimport { client as _heyApiClient } from \"./client.gen\";\n\nexport type Options<\n  TData extends TDataShape = TDataShape,\n  ThrowOnError extends boolean = boolean,\n> = ClientOptions<TData, ThrowOnError> & {\n  /**\n   * You can provide a client instance returned by `createClient()` instead of\n   * individual options. This might be also useful if you want to implement a\n   * custom client.\n   */\n  client?: Client;\n  /**\n   * You can pass arbitrary values through the `meta` object. This can be\n   * used to access values that aren't defined as part of the SDK function.\n   */\n  meta?: Record<string, unknown>;\n};\n\n/**\n * zoraSDK_apiKey query\n */\nexport const getApiKey = <ThrowOnError extends boolean = false>(\n  options: Options<GetApiKeyData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetApiKeyResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/apiKey\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_coin query\n */\nexport const getCoin = <ThrowOnError extends boolean = false>(\n  options: Options<GetCoinData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetCoinResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/coin\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_coinComments query\n */\nexport const getCoinComments = <ThrowOnError extends boolean = false>(\n  options: Options<GetCoinCommentsData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetCoinCommentsResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/coinComments\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_coins query\n */\nexport const getCoins = <ThrowOnError extends boolean = false>(\n  options: Options<GetCoinsData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetCoinsResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/coins\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_createUploadJWT mutation\n */\nexport const setCreateUploadJwt = <ThrowOnError extends boolean = false>(\n  options?: Options<SetCreateUploadJwtData, ThrowOnError>,\n) => {\n  return (options?.client ?? _heyApiClient).post<\n    SetCreateUploadJwtResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/createUploadJWT\",\n    ...options,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...options?.headers,\n    },\n  });\n};\n\n/**\n * zoraSDK_explore query\n */\nexport const getExplore = <ThrowOnError extends boolean = false>(\n  options: Options<GetExploreData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetExploreResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/explore\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_profile query\n */\nexport const getProfile = <ThrowOnError extends boolean = false>(\n  options: Options<GetProfileData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetProfileResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/profile\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_profileBalances query\n */\nexport const getProfileBalances = <ThrowOnError extends boolean = false>(\n  options: Options<GetProfileBalancesData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetProfileBalancesResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/profileBalances\",\n    ...options,\n  });\n};\n\n/**\n * zoraSDK_profileCoins query\n */\nexport const getProfileCoins = <ThrowOnError extends boolean = false>(\n  options: Options<GetProfileCoinsData, ThrowOnError>,\n) => {\n  return (options.client ?? _heyApiClient).get<\n    GetProfileCoinsResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"api-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/profileCoins\",\n    ...options,\n  });\n};\n","let apiKey: string | undefined;\nexport function setApiKey(key: string) {\n  apiKey = key;\n}\n\nexport function getApiKeyMeta() {\n  if (!apiKey) {\n    return {};\n  }\n  return {\n    headers: {\n      \"api-key\": apiKey,\n    },\n  };\n}\n","import {\n  GetCoinCommentsData,\n  GetCoinCommentsResponse,\n  GetCoinData,\n  GetCoinResponse,\n  GetCoinsData,\n  GetCoinsResponse,\n  GetProfileBalancesData,\n  GetProfileBalancesResponse,\n  GetProfileCoinsData,\n  GetProfileCoinsResponse,\n  GetProfileData,\n  GetProfileResponse,\n} from \"../client/types.gen\";\nimport {\n  getCoin as getCoinSDK,\n  getCoins as getCoinsSDK,\n  getCoinComments as getCoinCommentsSDK,\n  getProfile as getProfileSDK,\n  getProfileBalances as getProfileBalancesSDK,\n  getProfileCoins as getProfileCoinsSDK,\n} from \"../client/sdk.gen\";\nimport { getApiKeyMeta } from \"./api-key\";\nimport { RequestOptionsType } from \"./query-types\";\nimport { RequestResult } from \"@hey-api/client-fetch\";\n\nexport type { RequestResult };\n\ntype GetCoinQuery = GetCoinData[\"query\"];\nexport type { GetCoinQuery, GetCoinData };\nexport type { GetCoinResponse } from \"../client/types.gen\";\n\nexport type CoinData = NonNullable<GetCoinResponse[\"zora20Token\"]>;\n\nexport const getCoin = async (\n  query: GetCoinQuery,\n  options?: RequestOptionsType<GetCoinData>,\n): Promise<RequestResult<GetCoinResponse>> => {\n  return await getCoinSDK({\n    ...options,\n    query,\n    meta: getApiKeyMeta(),\n  });\n};\n\ntype GetCoinsQuery = GetCoinsData[\"query\"];\nexport type { GetCoinsQuery, GetCoinsData };\nexport type { GetCoinsResponse } from \"../client/types.gen\";\n\nexport const getCoins = async (\n  query: GetCoinsQuery,\n  options?: RequestOptionsType<GetCoinsData>,\n): Promise<RequestResult<GetCoinsResponse>> => {\n  return await getCoinsSDK({\n    query: {\n      coins: query.coins.map((coinData) => JSON.stringify(coinData)) as any,\n    },\n    meta: getApiKeyMeta(),\n    ...options,\n  });\n};\n\ntype GetCoinCommentsQuery = GetCoinCommentsData[\"query\"];\nexport type { GetCoinCommentsQuery, GetCoinCommentsData };\nexport type { GetCoinCommentsResponse } from \"../client/types.gen\";\n\nexport const getCoinComments = async (\n  query: GetCoinCommentsQuery,\n  options?: RequestOptionsType<GetCoinCommentsData>,\n): Promise<RequestResult<GetCoinCommentsResponse>> => {\n  return await getCoinCommentsSDK({\n    query,\n    meta: getApiKeyMeta(),\n    ...options,\n  });\n};\n\ntype GetProfileQuery = GetProfileData[\"query\"];\nexport type { GetProfileQuery, GetProfileData };\nexport type { GetProfileResponse } from \"../client/types.gen\";\n\nexport const getProfile = async (\n  query: GetProfileQuery,\n  options?: RequestOptionsType<GetProfileData>,\n): Promise<RequestResult<GetProfileResponse>> => {\n  return await getProfileSDK({\n    query,\n    meta: getApiKeyMeta(),\n    ...options,\n  });\n};\n\ntype GetProfileCoinsQuery = GetProfileCoinsData[\"query\"];\nexport type { GetProfileCoinsQuery, GetProfileCoinsData };\nexport type { GetProfileCoinsResponse } from \"../client/types.gen\";\n\nexport const getProfileCoins = async (\n  query: GetProfileCoinsQuery,\n  options?: RequestOptionsType<GetProfileCoinsData>,\n): Promise<RequestResult<GetProfileCoinsResponse>> => {\n  return await getProfileCoinsSDK({\n    query,\n    meta: getApiKeyMeta(),\n    ...options,\n  });\n};\n\ntype GetProfileBalancesQuery = GetProfileBalancesData[\"query\"];\nexport type { GetProfileBalancesQuery, GetProfileBalancesData };\nexport type { GetProfileBalancesResponse } from \"../client/types.gen\";\n\nexport const getProfileBalances = async (\n  query: GetProfileBalancesQuery,\n  options?: RequestOptionsType<GetProfileBalancesData>,\n): Promise<RequestResult<GetProfileBalancesResponse>> => {\n  return await getProfileBalancesSDK({\n    query,\n    meta: getApiKeyMeta(),\n    ...options,\n  });\n};\n","import { getExplore as getExploreSDK } from \"../client/sdk.gen\";\nimport type { GetExploreData, GetExploreResponse } from \"../client/types.gen\";\nimport { getApiKeyMeta } from \"./api-key\";\nimport { RequestOptionsType } from \"./query-types\";\n\n/**\n * The inner type for the explore queries that omits listType.\n * This is used to create the query object for the explore queries.\n */\nexport type QueryRequestType = Omit<GetExploreData[\"query\"], \"listType\">;\n\ntype ExploreResponse = { data?: GetExploreResponse };\n\nexport type ListType = GetExploreData[\"query\"][\"listType\"];\n\nexport type { ExploreResponse };\n\nexport type { GetExploreData };\n\n/**\n * Creates an explore query with the specified list type\n */\nconst createExploreQuery = (\n  query: QueryRequestType,\n  listType: ListType,\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  getExploreSDK({\n    ...options,\n    query: { ...query, listType },\n    meta: getApiKeyMeta(),\n  });\n\n/** Get top gaining coins */\nexport const getCoinsTopGainers = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"TOP_GAINERS\", options);\n\n/** Get coins with highest 24h volume */\nexport const getCoinsTopVolume24h = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"TOP_VOLUME_24H\", options);\n\n/** Get most valuable coins */\nexport const getCoinsMostValuable = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"MOST_VALUABLE\", options);\n\n/** Get newly created coins */\nexport const getCoinsNew = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> => createExploreQuery(query, \"NEW\", options);\n\n/** Get recently traded coins */\nexport const getCoinsLastTraded = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"LAST_TRADED\", options);\n\n/** Get recently traded unique coins */\nexport const getCoinsLastTradedUnique = (\n  query: QueryRequestType = {},\n  options?: RequestOptionsType<GetExploreData>,\n): Promise<ExploreResponse> =>\n  createExploreQuery(query, \"LAST_TRADED_UNIQUE\", options);\n"],"mappings":"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","names":["zeroAddress","keccak256","base","base","baseSepolia","base","baseSepolia","DeployCurrency","baseSepolia","base","zeroAddress","keccak256","zeroAddress","parseEventLogs","baseSepolia","zeroAddress","baseSepolia","parseEventLogs","coinABI","zeroAddress","coinABI","coinABI","parseEventLogs","coinABI","parseEventLogs","coinABI","parseEventLogs","coinABI","parseEventLogs","getCoin","getCoins","getCoinComments","getProfile","getProfileCoins","getProfileBalances"]}