// src/actions/createCoin.ts
import { coinFactoryABI as zoraFactoryImplABI } from "@zoralabs/protocol-deployments";
import {
  parseEventLogs,
  zeroAddress as zeroAddress2,
  keccak256 as keccak2562,
  toBytes
} from "viem";

// src/constants.ts
import { coinFactoryAddress as zoraFactoryImplAddress } from "@zoralabs/protocol-deployments";
import { base } from "viem/chains";
var COIN_FACTORY_ADDRESS = zoraFactoryImplAddress["8453"];
var SUPERCHAIN_WETH_ADDRESS = "0x4200000000000000000000000000000000000006";
var USDC_WETH_POOLS_BY_CHAIN = {
  [base.id]: "0xd0b53D9277642d899DF5C87A3966A349A798F224"
};

// src/utils/validateClientNetwork.ts
import { base as base2, baseSepolia } from "viem/chains";
var validateClientNetwork = (publicClient) => {
  const clientChainId = publicClient?.chain?.id;
  if (clientChainId === base2.id) {
    return;
  }
  if (clientChainId === baseSepolia.id) {
    return;
  }
  throw new Error(
    "Client network needs to be base or baseSepolia for current coin deployments."
  );
};

// src/metadata/cleanAndValidateMetadataURI.ts
function cleanAndValidateMetadataURI(uri) {
  if (uri.startsWith("ipfs://")) {
    return uri.replace(
      "ipfs://",
      "https://magic.decentralized-content.com/ipfs/"
    );
  }
  if (uri.startsWith("ar://")) {
    return uri.replace("ar://", "http://arweave.net/");
  }
  if (uri.startsWith("data:")) {
    return uri;
  }
  if (uri.startsWith("http://") || uri.startsWith("https://")) {
    return uri;
  }
  throw new Error("Invalid metadata URI");
}

// src/metadata/validateMetadataJSON.ts
function validateURIString(uri) {
  if (typeof uri !== "string") {
    throw new Error("URI must be a string");
  }
  if (uri.startsWith("ipfs://")) {
    return true;
  }
  if (uri.startsWith("ar://")) {
    return true;
  }
  if (uri.startsWith("https://")) {
    return true;
  }
  if (uri.startsWith("data:")) {
    return true;
  }
  return false;
}
function validateMetadataJSON(metadata) {
  if (typeof metadata !== "object" || !metadata) {
    throw new Error("Metadata must be an object and exist");
  }
  if (typeof metadata.name !== "string") {
    throw new Error("Metadata name is required and must be a string");
  }
  if (typeof metadata.description !== "string") {
    throw new Error("Metadata description is required and must be a string");
  }
  if (typeof metadata.image === "string") {
    if (!validateURIString(metadata.image)) {
      throw new Error("Metadata image is not a valid URI");
    }
  } else {
    throw new Error("Metadata image is required and must be a string");
  }
  if ("animation_url" in metadata) {
    if (typeof metadata.animation_url !== "string") {
      throw new Error("Metadata animation_url, if provided, must be a string");
    }
    if (!validateURIString(metadata.animation_url)) {
      throw new Error("Metadata animation_url is not a valid URI");
    }
  }
  const content = "content" in metadata && metadata.content;
  if (content) {
    if (typeof content.uri !== "string") {
      throw new Error("If provided, content.uri must be a string");
    }
    if (!validateURIString(content.uri)) {
      throw new Error("If provided, content.uri must be a valid URI string");
    }
    if (typeof content.mime !== "string") {
      throw new Error("If provided, content.mime must be a string");
    }
  }
  return true;
}

// src/metadata/validateMetadataURIContent.ts
async function validateMetadataURIContent(metadataURI) {
  const cleanedURI = cleanAndValidateMetadataURI(metadataURI);
  const response = await fetch(cleanedURI);
  if (!response.ok) {
    throw new Error("Metadata fetch failed");
  }
  if (!["application/json", "text/plain"].includes(
    response.headers.get("content-type") ?? ""
  )) {
    throw new Error("Metadata is not a valid JSON or plain text response type");
  }
  const metadataJson = await response.json();
  return validateMetadataJSON(metadataJson);
}

// src/utils/attribution.ts
import { keccak256, slice, toHex } from "viem";
function getAttribution() {
  const hash = keccak256(toHex("api-sdk.zora.engineering"));
  return slice(hash, 0, 4);
}

// src/actions/createCoin.ts
import { base as base4, baseSepolia as baseSepolia3 } from "viem/chains";

// src/utils/poolConfigUtils.ts
import { encodeMultiCurvePoolConfig } from "@zoralabs/protocol-deployments";
import { parseUnits, zeroAddress } from "viem";
import { base as base3, baseSepolia as baseSepolia2 } from "viem/chains";
var ZORA_DECIMALS = 18;
var ZORA_ADDRESS = "0x1111111111166b7fe7bd91427724b487980afc69";
var COIN_ETH_PAIR_LOWER_TICK = -25e4;
var COIN_ETH_PAIR_UPPER_TICK = -195e3;
var COIN_ETH_PAIR_NUM_DISCOVERY_POSITIONS = 11;
var COIN_ETH_PAIR_MAX_DISCOVERY_SUPPLY_SHARE = parseUnits("0.05", 18);
var COIN_ETH_PAIR_POOL_CONFIG = {
  [base3.id]: encodeMultiCurvePoolConfig({
    currency: zeroAddress,
    tickLower: [COIN_ETH_PAIR_LOWER_TICK],
    tickUpper: [COIN_ETH_PAIR_UPPER_TICK],
    numDiscoveryPositions: [COIN_ETH_PAIR_NUM_DISCOVERY_POSITIONS],
    maxDiscoverySupplyShare: [COIN_ETH_PAIR_MAX_DISCOVERY_SUPPLY_SHARE]
  }),
  [baseSepolia2.id]: encodeMultiCurvePoolConfig({
    currency: zeroAddress,
    tickLower: [COIN_ETH_PAIR_LOWER_TICK],
    tickUpper: [COIN_ETH_PAIR_UPPER_TICK],
    numDiscoveryPositions: [COIN_ETH_PAIR_NUM_DISCOVERY_POSITIONS],
    maxDiscoverySupplyShare: [COIN_ETH_PAIR_MAX_DISCOVERY_SUPPLY_SHARE]
  })
};
var COIN_ZORA_PAIR_LOWER_TICK = -138e3;
var COIN_ZORA_PAIR_UPPER_TICK = -81e3;
var COIN_ZORA_PAIR_NUM_DISCOVERY_POSITIONS = 11;
var COIN_ZORA_PAIR_MAX_DISCOVERY_SUPPLY_SHARE = parseUnits(
  "0.05",
  ZORA_DECIMALS
);
var COIN_ZORA_PAIR_POOL_CONFIG = {
  [base3.id]: encodeMultiCurvePoolConfig({
    currency: ZORA_ADDRESS,
    tickLower: [COIN_ZORA_PAIR_LOWER_TICK],
    tickUpper: [COIN_ZORA_PAIR_UPPER_TICK],
    numDiscoveryPositions: [COIN_ZORA_PAIR_NUM_DISCOVERY_POSITIONS],
    maxDiscoverySupplyShare: [COIN_ZORA_PAIR_MAX_DISCOVERY_SUPPLY_SHARE]
  })
};

// src/actions/createCoin.ts
var DeployCurrency = /* @__PURE__ */ ((DeployCurrency2) => {
  DeployCurrency2[DeployCurrency2["ZORA"] = 1] = "ZORA";
  DeployCurrency2[DeployCurrency2["ETH"] = 2] = "ETH";
  return DeployCurrency2;
})(DeployCurrency || {});
function getPoolConfig(currency, chainId) {
  if (currency === 1 /* ZORA */ && chainId == baseSepolia3.id) {
    throw new Error("ZORA is not supported on Base Sepolia");
  }
  switch (currency) {
    case 1 /* ZORA */:
      return COIN_ZORA_PAIR_POOL_CONFIG[chainId];
    case 2 /* ETH */:
      return COIN_ETH_PAIR_POOL_CONFIG[chainId];
    default:
      throw new Error("Invalid currency");
  }
}
async function createCoinCall({
  name,
  symbol,
  uri,
  owners,
  payoutRecipient,
  currency,
  chainId = base4.id,
  platformReferrer = "0x0000000000000000000000000000000000000000"
}) {
  if (!owners) {
    owners = [payoutRecipient];
  }
  if (!currency) {
    currency = chainId !== base4.id ? 2 /* ETH */ : 1 /* ZORA */;
  }
  const poolConfig = getPoolConfig(currency, chainId);
  await validateMetadataURIContent(uri);
  return {
    abi: zoraFactoryImplABI,
    functionName: "deploy",
    address: COIN_FACTORY_ADDRESS,
    args: [
      payoutRecipient,
      owners,
      uri,
      name,
      symbol,
      poolConfig,
      platformReferrer,
      zeroAddress2,
      // hookAddress
      "0x",
      // hookData
      keccak2562(toBytes(Math.random().toString()))
      // coinSalt
    ],
    dataSuffix: getAttribution()
  };
}
function getCoinCreateFromLogs(receipt) {
  const eventLogs = parseEventLogs({
    abi: zoraFactoryImplABI,
    logs: receipt.logs
  });
  return eventLogs.find((log) => log.eventName === "CoinCreatedV4")?.args;
}
async function createCoin(call, walletClient, publicClient, options) {
  validateClientNetwork(publicClient);
  const createCoinRequest = await createCoinCall(call);
  const { request } = await publicClient.simulateContract({
    ...createCoinRequest,
    account: options?.account ?? walletClient.account
  });
  if (request.gas) {
    request.gas = request.gas * BigInt(options?.gasMultiplier ?? 100) / 100n;
  }
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const deployment = getCoinCreateFromLogs(receipt);
  return {
    hash,
    receipt,
    address: deployment?.coin,
    deployment
  };
}

// src/actions/tradeCoin.ts
import { coinABI } from "@zoralabs/protocol-deployments";
import {
  parseEther,
  zeroAddress as zeroAddress3,
  parseEventLogs as parseEventLogs2
} from "viem";
import { baseSepolia as baseSepolia4 } from "viem/chains";
var OP_BRIDGE_ADDRESS = "0x4200000000000000000000000000000000000016";
async function simulateBuy({
  target,
  requestedOrderSize,
  publicClient
}) {
  const numberResult = await publicClient.simulateContract({
    address: target,
    abi: coinABI,
    functionName: "buy",
    dataSuffix: getAttribution(),
    args: [
      OP_BRIDGE_ADDRESS,
      requestedOrderSize,
      0n,
      // minAmountOut
      0n,
      // sqrtPriceLimitX96
      zeroAddress3
      // tradeReferrer
    ],
    // We want to ensure that the multicall3 contract has enough ETH to buy in the simulation
    stateOverride: [
      {
        address: baseSepolia4.contracts.multicall3.address,
        balance: parseEther("10000000")
      }
    ]
  });
  const orderSize = numberResult.result[0];
  const amountOut = numberResult.result[1];
  return { orderSize, amountOut };
}
function tradeCoinCall({
  target,
  direction,
  args: {
    recipient,
    orderSize,
    minAmountOut = 0n,
    sqrtPriceLimitX96 = 0n,
    tradeReferrer = zeroAddress3
  }
}) {
  return {
    abi: coinABI,
    functionName: direction,
    address: target,
    args: [
      recipient,
      orderSize,
      minAmountOut,
      sqrtPriceLimitX96,
      tradeReferrer
    ],
    value: direction === "buy" ? orderSize : 0n
  };
}
function getTradeFromLogs(receipt, direction) {
  const eventLogs = parseEventLogs2({
    abi: coinABI,
    logs: receipt.logs
  });
  if (direction === "buy") {
    return eventLogs.find((log) => log.eventName === "CoinBuy")?.args;
  }
  return eventLogs.find((log) => log.eventName === "CoinSell")?.args;
}
async function tradeCoin(params, walletClient, publicClient) {
  validateClientNetwork(publicClient);
  const { request } = await publicClient.simulateContract({
    ...tradeCoinCall(params),
    account: walletClient.account
  });
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const trade = getTradeFromLogs(receipt, params.direction);
  return {
    hash,
    receipt,
    trade
  };
}

// src/actions/getOnchainCoinDetails.ts
import { coinABI as coinABI2, iUniswapV3PoolABI } from "@zoralabs/protocol-deployments";
import {
  erc20Abi,
  formatEther,
  isAddressEqual,
  zeroAddress as zeroAddress4
} from "viem";
async function getOnchainCoinDetails({
  coin,
  user = zeroAddress4,
  publicClient
}) {
  validateClientNetwork(publicClient);
  const [balance, pool, owners, payoutRecipient] = await publicClient.multicall(
    {
      contracts: [
        {
          address: coin,
          abi: coinABI2,
          functionName: "balanceOf",
          args: [user]
        },
        {
          address: coin,
          abi: coinABI2,
          functionName: "poolAddress"
        },
        {
          address: coin,
          abi: coinABI2,
          functionName: "owners"
        },
        {
          address: coin,
          abi: coinABI2,
          functionName: "payoutRecipient"
        }
      ],
      allowFailure: false
    }
  );
  const USDC_WETH_POOL = USDC_WETH_POOLS_BY_CHAIN[publicClient.chain?.id || 0];
  const [
    coinWethPoolSlot0,
    coinWethPoolToken0,
    coinReservesRaw,
    coinTotalSupply,
    wethReservesRaw,
    usdcWethSlot0
  ] = await publicClient.multicall({
    contracts: [
      {
        address: pool,
        abi: iUniswapV3PoolABI,
        functionName: "slot0"
      },
      {
        address: pool,
        abi: iUniswapV3PoolABI,
        functionName: "token0"
      },
      {
        address: coin,
        abi: erc20Abi,
        functionName: "balanceOf",
        args: [pool]
      },
      {
        address: coin,
        abi: coinABI2,
        functionName: "totalSupply"
      },
      {
        address: SUPERCHAIN_WETH_ADDRESS,
        abi: erc20Abi,
        functionName: "balanceOf",
        args: [pool]
      },
      {
        address: USDC_WETH_POOL ?? coin,
        abi: iUniswapV3PoolABI,
        functionName: "slot0"
      }
    ],
    allowFailure: false
  });
  const wethPriceInUsdc = USDC_WETH_POOL ? uniswapV3SqrtPriceToBigIntScaled(
    usdcWethSlot0.sqrtPriceX96,
    18,
    6,
    true,
    18
  ) : null;
  const coinPriceInWeth = uniswapV3SqrtPriceToBigIntScaled(
    coinWethPoolSlot0.sqrtPriceX96,
    18,
    18,
    isAddressEqual(coinWethPoolToken0, coin),
    18
  );
  const marketCap = coinPriceInWeth * coinTotalSupply / 10n ** 18n;
  const wethLiquidity = wethReservesRaw;
  const tokenLiquidity = coinReservesRaw * coinPriceInWeth / 10n ** 18n;
  return {
    balance,
    pool,
    owners,
    payoutRecipient,
    marketCap: convertEthOutput(marketCap, wethPriceInUsdc),
    liquidity: convertEthOutput(
      wethLiquidity + tokenLiquidity,
      wethPriceInUsdc
    ),
    poolState: coinWethPoolSlot0
  };
}
function convertEthOutput(amountETH, wethToUsdc) {
  return {
    eth: amountETH,
    ethDecimal: parseFloat(formatEther(amountETH)),
    usdc: wethToUsdc ? amountETH * wethToUsdc : null,
    usdcDecimal: wethToUsdc ? parseFloat(formatEther(amountETH * wethToUsdc / 10n ** 18n)) : null
  };
}
function uniswapV3SqrtPriceToBigIntScaled(sqrtPriceX96, token0Decimals, token1Decimals, isToken0Coin, scaleDecimals = 18) {
  const numerator = sqrtPriceX96 * sqrtPriceX96;
  const denominator = 2n ** 192n;
  const scaleFactor = 10n ** BigInt(scaleDecimals);
  let ratioScaled = numerator * scaleFactor / denominator;
  const decimalsDiff = BigInt(token0Decimals - token1Decimals);
  if (decimalsDiff > 0n) {
    ratioScaled *= 10n ** decimalsDiff;
  } else if (decimalsDiff < 0n) {
    ratioScaled /= 10n ** -decimalsDiff;
  }
  if (!isToken0Coin) {
    if (ratioScaled === 0n) {
      return 0n;
    }
    ratioScaled = scaleFactor * scaleFactor / ratioScaled;
  }
  return ratioScaled;
}

// src/actions/updateCoinURI.ts
import { coinABI as coinABI3 } from "@zoralabs/protocol-deployments";
import {
  parseEventLogs as parseEventLogs3
} from "viem";
function updateCoinURICall({
  newURI,
  coin
}) {
  if (!newURI.startsWith("ipfs://")) {
    throw new Error("URI needs to be an ipfs:// prefix uri");
  }
  return {
    abi: coinABI3,
    address: coin,
    functionName: "setContractURI",
    args: [newURI],
    dataSuffix: getAttribution()
  };
}
async function updateCoinURI(args, walletClient, publicClient) {
  validateClientNetwork(publicClient);
  const call = updateCoinURICall(args);
  const { request } = await publicClient.simulateContract({
    ...call,
    account: walletClient.account
  });
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const eventLogs = parseEventLogs3({ abi: coinABI3, logs: receipt.logs });
  const uriUpdated = eventLogs.find(
    (log) => log.eventName === "ContractURIUpdated"
  );
  return { hash, receipt, uriUpdated };
}

// src/actions/updatePayoutRecipient.ts
import { coinABI as coinABI4 } from "@zoralabs/protocol-deployments";
import {
  parseEventLogs as parseEventLogs4
} from "viem";
function updatePayoutRecipientCall({
  newPayoutRecipient,
  coin
}) {
  return {
    abi: coinABI4,
    address: coin,
    functionName: "setPayoutRecipient",
    args: [newPayoutRecipient],
    dataSuffix: getAttribution()
  };
}
async function updatePayoutRecipient(args, walletClient, publicClient) {
  validateClientNetwork(publicClient);
  const call = updatePayoutRecipientCall(args);
  const { request } = await publicClient.simulateContract({
    ...call,
    account: walletClient.account
  });
  const hash = await walletClient.writeContract(request);
  const receipt = await publicClient.waitForTransactionReceipt({ hash });
  const eventLogs = parseEventLogs4({ abi: coinABI4, logs: receipt.logs });
  const payoutRecipientUpdated = eventLogs.find(
    (log) => log.eventName === "CoinPayoutRecipientUpdated"
  );
  return { hash, receipt, payoutRecipientUpdated };
}

// src/client/client.gen.ts
import {
  createClient,
  createConfig
} from "@hey-api/client-fetch";
var client = createClient(
  createConfig({
    baseUrl: "https://api-sdk.zora.engineering/"
  })
);

// src/client/sdk.gen.ts
var getCoin = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/coin",
    ...options
  });
};
var getCoinComments = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/coinComments",
    ...options
  });
};
var getCoins = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/coins",
    ...options
  });
};
var getExplore = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/explore",
    ...options
  });
};
var getProfile = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/profile",
    ...options
  });
};
var getProfileBalances = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/profileBalances",
    ...options
  });
};
var getProfileCoins = (options) => {
  return (options.client ?? client).get({
    security: [
      {
        name: "api-key",
        type: "apiKey"
      }
    ],
    url: "/profileCoins",
    ...options
  });
};

// src/api/api-key.ts
var apiKey;
function setApiKey(key) {
  apiKey = key;
}
function getApiKeyMeta() {
  if (!apiKey) {
    return {};
  }
  return {
    headers: {
      "api-key": apiKey
    }
  };
}

// src/api/queries.ts
var getCoin2 = async (query, options) => {
  return await getCoin({
    ...options,
    query,
    meta: getApiKeyMeta()
  });
};
var getCoins2 = async (query, options) => {
  return await getCoins({
    query: {
      coins: query.coins.map((coinData) => JSON.stringify(coinData))
    },
    meta: getApiKeyMeta(),
    ...options
  });
};
var getCoinComments2 = async (query, options) => {
  return await getCoinComments({
    query,
    meta: getApiKeyMeta(),
    ...options
  });
};
var getProfile2 = async (query, options) => {
  return await getProfile({
    query,
    meta: getApiKeyMeta(),
    ...options
  });
};
var getProfileCoins2 = async (query, options) => {
  return await getProfileCoins({
    query,
    meta: getApiKeyMeta(),
    ...options
  });
};
var getProfileBalances2 = async (query, options) => {
  return await getProfileBalances({
    query,
    meta: getApiKeyMeta(),
    ...options
  });
};

// src/api/explore.ts
var createExploreQuery = (query, listType, options) => getExplore({
  ...options,
  query: { ...query, listType },
  meta: getApiKeyMeta()
});
var getCoinsTopGainers = (query = {}, options) => createExploreQuery(query, "TOP_GAINERS", options);
var getCoinsTopVolume24h = (query = {}, options) => createExploreQuery(query, "TOP_VOLUME_24H", options);
var getCoinsMostValuable = (query = {}, options) => createExploreQuery(query, "MOST_VALUABLE", options);
var getCoinsNew = (query = {}, options) => createExploreQuery(query, "NEW", options);
var getCoinsLastTraded = (query = {}, options) => createExploreQuery(query, "LAST_TRADED", options);
var getCoinsLastTradedUnique = (query = {}, options) => createExploreQuery(query, "LAST_TRADED_UNIQUE", options);
export {
  DeployCurrency,
  cleanAndValidateMetadataURI,
  createCoin,
  createCoinCall,
  getCoin2 as getCoin,
  getCoinComments2 as getCoinComments,
  getCoinCreateFromLogs,
  getCoins2 as getCoins,
  getCoinsLastTraded,
  getCoinsLastTradedUnique,
  getCoinsMostValuable,
  getCoinsNew,
  getCoinsTopGainers,
  getCoinsTopVolume24h,
  getOnchainCoinDetails,
  getProfile2 as getProfile,
  getProfileBalances2 as getProfileBalances,
  getProfileCoins2 as getProfileCoins,
  getTradeFromLogs,
  setApiKey,
  simulateBuy,
  tradeCoin,
  tradeCoinCall,
  updateCoinURI,
  updateCoinURICall,
  updatePayoutRecipient,
  updatePayoutRecipientCall,
  validateMetadataJSON,
  validateMetadataURIContent
};
//# sourceMappingURL=index.js.map